{"version":3,"file":"index.cjs","sources":["../src/fsrs/models.ts","../src/fsrs/convert.ts","../src/fsrs/help.ts","../src/fsrs/default.ts","../src/fsrs/alea.ts","../src/fsrs/algorithm.ts","../src/fsrs/strategies/seed.ts","../src/fsrs/strategies/types.ts","../src/fsrs/abstract_scheduler.ts","../src/fsrs/impl/basic_scheduler.ts","../src/fsrs/impl/long_term_scheduler.ts","../src/fsrs/reschedule.ts","../src/fsrs/fsrs.ts"],"sourcesContent":["export type StateType = 'New' | 'Learning' | 'Review' | 'Relearning'\n\nexport enum State {\n  New = 0,\n  Learning = 1,\n  Review = 2,\n  Relearning = 3,\n}\n\nexport type RatingType = 'Manual' | 'Again' | 'Hard' | 'Good' | 'Easy'\n\nexport enum Rating {\n  Manual = 0,\n  Again = 1,\n  Hard = 2,\n  Good = 3,\n  Easy = 4,\n}\n\ntype ExcludeManual<T> = Exclude<T, Rating.Manual>\n\nexport type Grade = ExcludeManual<Rating>\n\nexport interface ReviewLog {\n  rating: Rating // Rating of the review (Again, Hard, Good, Easy)\n  state: State // State of the review (New, Learning, Review, Relearning)\n  due: Date // Date of the last scheduling\n  stability: number // Memory stability during the review\n  difficulty: number // Difficulty of the card during the review\n  elapsed_days: number // Number of days elapsed since the last review\n  last_elapsed_days: number // Number of days between the last two reviews\n  scheduled_days: number // Number of days until the next review\n  review: Date // Date of the review\n}\n\nexport type RecordLogItem = {\n  card: Card\n  log: ReviewLog\n}\nexport type RecordLog = {\n  [key in Grade]: RecordLogItem\n}\n\nexport interface Card {\n  due: Date // Due date\n  stability: number // Stability\n  difficulty: number // Difficulty level\n  elapsed_days: number // Number of days elapsed\n  scheduled_days: number // Number of days scheduled\n  reps: number // Repetition count\n  lapses: number // Number of lapses or mistakes\n  state: State // Card's state (New, Learning, Review, Relearning)\n  last_review?: Date // Date of the last review (optional)\n}\n\nexport interface CardInput extends Omit<Card, 'state' | 'due' | 'last_review'> {\n  state: StateType | State // Card's state (New, Learning, Review, Relearning)\n  due: DateInput // Due date\n  last_review?: DateInput | null // Date of the last review (optional)\n}\n\nexport type DateInput = Date | number | string\n\nexport interface ReviewLogInput\n  extends Omit<ReviewLog, 'rating' | 'state' | 'due' | 'review'> {\n  rating: RatingType | Rating // Rating of the review (Again, Hard, Good, Easy)\n  state: StateType | State // Card's state (New, Learning, Review, Relearning)\n  due: DateInput // Due date\n  review: DateInput // Date of the last review\n}\n\nexport interface FSRSParameters {\n  request_retention: number\n  maximum_interval: number\n  w: number[]\n  enable_fuzz: boolean\n  enable_short_term: boolean\n}\n\nexport interface FSRSReview {\n  /**\n   * 0-4: Manual, Again, Hard, Good, Easy\n   * = revlog.rating\n   */\n  rating: Rating\n  /**\n   * The number of days that passed\n   * = revlog.elapsed_days\n   * = round(revlog[-1].review - revlog[-2].review)\n   */\n  delta_t: number\n}\n\nexport type FSRSHistory = Partial<\n  Omit<ReviewLog, 'rating' | 'review' | 'elapsed_days'>\n> &\n  (\n    | {\n        rating: Grade\n        review: DateInput | Date\n      }\n    | {\n        rating: Rating.Manual\n        due: DateInput | Date\n        state: State\n        review: DateInput | Date\n      }\n  )\n\nexport interface FSRSState {\n  stability: number\n  difficulty: number\n}\n","import {\n  Card,\n  CardInput,\n  Rating,\n  ReviewLog,\n  ReviewLogInput,\n  State,\n} from './models'\n\nexport class TypeConvert {\n  static card<T extends Card | CardInput>(card: T): Card {\n    return {\n      ...card,\n      state: TypeConvert.state(card.state),\n      due: TypeConvert.time(card.due),\n      last_review: card.last_review\n        ? TypeConvert.time(card.last_review)\n        : undefined,\n    } as Card\n  }\n  static rating(value: unknown): Rating {\n    if (typeof value === 'string') {\n      const firstLetter = value.charAt(0).toUpperCase()\n      const restOfString = value.slice(1).toLowerCase()\n      const ret = Rating[`${firstLetter}${restOfString}` as keyof typeof Rating]\n      if (ret === undefined) {\n        throw new Error(`Invalid rating:[${value}]`)\n      }\n      return ret\n    } else if (typeof value === 'number') {\n      return value as Rating\n    }\n    throw new Error(`Invalid rating:[${value}]`)\n  }\n  static state(value: unknown): State {\n    if (typeof value === 'string') {\n      const firstLetter = value.charAt(0).toUpperCase()\n      const restOfString = value.slice(1).toLowerCase()\n      const ret = State[`${firstLetter}${restOfString}` as keyof typeof State]\n      if (ret === undefined) {\n        throw new Error(`Invalid state:[${value}]`)\n      }\n      return ret\n    } else if (typeof value === 'number') {\n      return value as State\n    }\n    throw new Error(`Invalid state:[${value}]`)\n  }\n  static time(value: unknown): Date {\n    if (typeof value === 'object' && value instanceof Date) {\n      return value\n    } else if (typeof value === 'string') {\n      const timestamp = Date.parse(value)\n      if (!isNaN(timestamp)) {\n        return new Date(timestamp)\n      } else {\n        throw new Error(`Invalid date:[${value}]`)\n      }\n    } else if (typeof value === 'number') {\n      return new Date(value)\n    }\n    throw new Error(`Invalid date:[${value}]`)\n  }\n  static review_log(log: ReviewLogInput | ReviewLog): ReviewLog {\n    return {\n      ...log,\n      due: TypeConvert.time(log.due),\n      rating: TypeConvert.rating(log.rating),\n      state: TypeConvert.state(log.state),\n      review: TypeConvert.time(log.review),\n    } satisfies ReviewLog\n  }\n}\n","import type { int, unit } from './types'\nimport type { DateInput, Grade } from './models'\nimport { Rating, State } from './models'\nimport { TypeConvert } from './convert'\n\ndeclare global {\n  export interface Date {\n    scheduler(t: int, isDay?: boolean): Date\n\n    diff(pre: Date, unit: unit): int\n\n    format(): string\n\n    dueFormat(last_review: Date, unit?: boolean, timeUnit?: string[]): string\n  }\n}\n\nDate.prototype.scheduler = function (t: int, isDay?: boolean): Date {\n  return date_scheduler(this, t, isDay)\n}\n\n/**\n * 当前时间与之前的时间差值\n * @param pre 比当前时间还要之前\n * @param unit 单位: days | minutes\n */\nDate.prototype.diff = function (pre: Date, unit: unit): int {\n  return date_diff(this, pre, unit) as int\n}\n\nDate.prototype.format = function (): string {\n  return formatDate(this)\n}\n\nDate.prototype.dueFormat = function (\n  last_review: Date,\n  unit?: boolean,\n  timeUnit?: string[]\n) {\n  return show_diff_message(this, last_review, unit, timeUnit)\n}\n\n/**\n * 计算日期和时间的偏移，并返回一个新的日期对象。\n * @param now 当前日期和时间\n * @param t 时间偏移量，当 isDay 为 true 时表示天数，为 false 时表示分钟\n * @param isDay （可选）是否按天数单位进行偏移，默认为 false，表示按分钟单位计算偏移\n * @returns 偏移后的日期和时间对象\n */\nexport function date_scheduler(\n  now: DateInput,\n  t: number,\n  isDay?: boolean\n): Date {\n  return new Date(\n    isDay\n      ? TypeConvert.time(now).getTime() + t * 24 * 60 * 60 * 1000\n      : TypeConvert.time(now).getTime() + t * 60 * 1000\n  )\n}\n\nexport function date_diff(now: DateInput, pre: DateInput, unit: unit): number {\n  if (!now || !pre) {\n    throw new Error('Invalid date')\n  }\n  const diff = TypeConvert.time(now).getTime() - TypeConvert.time(pre).getTime()\n  let r = 0\n  switch (unit) {\n    case 'days':\n      r = Math.floor(diff / (24 * 60 * 60 * 1000))\n      break\n    case 'minutes':\n      r = Math.floor(diff / (60 * 1000))\n      break\n  }\n  return r\n}\n\nexport function formatDate(dateInput: DateInput): string {\n  const date = TypeConvert.time(dateInput)\n  const year: number = date.getFullYear()\n  const month: number = date.getMonth() + 1\n  const day: number = date.getDate()\n  const hours: number = date.getHours()\n  const minutes: number = date.getMinutes()\n  const seconds: number = date.getSeconds()\n\n  return `${year}-${padZero(month)}-${padZero(day)} ${padZero(hours)}:${padZero(\n    minutes\n  )}:${padZero(seconds)}`\n}\n\nfunction padZero(num: number): string {\n  return num < 10 ? `0${num}` : `${num}`\n}\n\nconst TIMEUNIT = [60, 60, 24, 31, 12]\nconst TIMEUNITFORMAT = ['second', 'min', 'hour', 'day', 'month', 'year']\n\nexport function show_diff_message(\n  due: DateInput,\n  last_review: DateInput,\n  unit?: boolean,\n  timeUnit: string[] = TIMEUNITFORMAT\n): string {\n  due = TypeConvert.time(due)\n  last_review = TypeConvert.time(last_review)\n  if (timeUnit.length !== TIMEUNITFORMAT.length) {\n    timeUnit = TIMEUNITFORMAT\n  }\n  let diff = due.getTime() - last_review.getTime()\n  let i\n  diff /= 1000\n  for (i = 0; i < TIMEUNIT.length; i++) {\n    if (diff < TIMEUNIT[i]) {\n      break\n    } else {\n      diff /= TIMEUNIT[i]\n    }\n  }\n  return `${Math.floor(diff)}${unit ? timeUnit[i] : ''}`\n}\n\n/**\n *\n * @deprecated Use TypeConvert.time instead\n */\nexport function fixDate(value: unknown) {\n  return TypeConvert.time(value)\n}\n\n/**\n * @deprecated Use TypeConvert.state instead\n */\nexport function fixState(value: unknown): State {\n  return TypeConvert.state(value)\n}\n\n/**\n * @deprecated Use TypeConvert.rating instead\n */\nexport function fixRating(value: unknown): Rating {\n  return TypeConvert.rating(value)\n}\n\nexport const Grades: Readonly<Grade[]> = [\n  Rating.Again,\n  Rating.Hard,\n  Rating.Good,\n  Rating.Easy,\n] as const\n\nconst FUZZ_RANGES = [\n  {\n    start: 2.5,\n    end: 7.0,\n    factor: 0.15,\n  },\n  {\n    start: 7.0,\n    end: 20.0,\n    factor: 0.1,\n  },\n  {\n    start: 20.0,\n    end: Infinity,\n    factor: 0.05,\n  },\n] as const\n\nexport function get_fuzz_range(\n  interval: number,\n  elapsed_days: number,\n  maximum_interval: number\n) {\n  let delta = 1.0\n  for (const range of FUZZ_RANGES) {\n    delta +=\n      range.factor * Math.max(Math.min(interval, range.end) - range.start, 0.0)\n  }\n  interval = Math.min(interval, maximum_interval)\n  let min_ivl = Math.max(2, Math.round(interval - delta))\n  const max_ivl = Math.min(Math.round(interval + delta), maximum_interval)\n  if (interval > elapsed_days) {\n    min_ivl = Math.max(min_ivl, elapsed_days + 1)\n  }\n  min_ivl = Math.min(min_ivl, max_ivl)\n  return { min_ivl, max_ivl }\n}\n\nexport function clamp(value: number, min: number, max: number): number {\n  return Math.min(Math.max(value, min), max)\n}\n\nexport function dateDiffInDays(last: Date, cur: Date) {\n  // Discard the time and time-zone information.\n  const utc1 = Date.UTC(\n    last.getUTCFullYear(),\n    last.getUTCMonth(),\n    last.getUTCDate()\n  )\n  const utc2 = Date.UTC(\n    cur.getUTCFullYear(),\n    cur.getUTCMonth(),\n    cur.getUTCDate()\n  )\n\n  return Math.floor((utc2 - utc1) / 86400000 /** 1000 * 60 * 60 * 24*/)\n}\n","import { Card, DateInput, FSRSParameters, State } from './models'\nimport { TypeConvert } from './convert'\nimport { version } from '../../package.json'\nimport { clamp } from './help'\n\nexport const default_request_retention = 0.9\nexport const default_maximum_interval = 36500\nexport const default_w = [\n  0.40255, 1.18385, 3.173, 15.69105, 7.1949, 0.5345, 1.4604, 0.0046, 1.54575,\n  0.1192, 1.01925, 1.9395, 0.11, 0.29605, 2.2698, 0.2315, 2.9898, 0.51655,\n  0.6621,\n]\nexport const default_enable_fuzz = false\nexport const default_enable_short_term = true\n\nexport const FSRSVersion: string = `v${version} using FSRS-5.0`\n\nexport const S_MIN = 0.01\nexport const INIT_S_MAX = 100.0\nexport const CLAMP_PARAMETERS: Array<[number /**min */, number /**max */]> = [\n  [S_MIN, INIT_S_MAX] /** initial stability (Again) */,\n  [S_MIN, INIT_S_MAX] /** initial stability (Hard) */,\n  [S_MIN, INIT_S_MAX] /** initial stability (Good) */,\n  [S_MIN, INIT_S_MAX] /** initial stability (Easy) */,\n  [1.0, 10.0] /** initial difficulty (Good) */,\n  [0.001, 4.0] /** initial difficulty (multiplier) */,\n  [0.001, 4.0] /** difficulty (multiplier) */,\n  [0.001, 0.75] /** difficulty (multiplier) */,\n  [0.0, 4.5] /** stability (exponent) */,\n  [0.0, 0.8] /** stability (negative power) */,\n  [0.001, 3.5] /** stability (exponent) */,\n  [0.001, 5.0] /** fail stability (multiplier) */,\n  [0.001, 0.25] /** fail stability (negative power) */,\n  [0.001, 0.9] /** fail stability (power) */,\n  [0.0, 4.0] /** fail stability (exponent) */,\n  [0.0, 1.0] /** stability (multiplier for Hard) */,\n  [1.0, 6.0] /** stability (multiplier for Easy) */,\n  [0.0, 2.0] /** short-term stability (exponent) */,\n  [0.0, 2.0] /** short-term stability (exponent) */,\n]\n\nexport const generatorParameters = (\n  props?: Partial<FSRSParameters>\n): FSRSParameters => {\n  let w = default_w\n  if (props?.w) {\n    if (props.w.length === 19) {\n      w = props?.w\n    } else if (props.w.length === 17) {\n      w = props?.w.concat([0.0, 0.0])\n      w[4] = +(w[5] * 2.0 + w[4]).toFixed(8)\n      w[5] = +(Math.log(w[5] * 3.0 + 1.0) / 3.0).toFixed(8)\n      w[6] = +(w[6] + 0.5).toFixed(8)\n      console.debug('[FSRS V5]auto fill w to 19 length')\n    }\n  }\n  w = w.map((w, index) =>\n    clamp(w, CLAMP_PARAMETERS[index][0], CLAMP_PARAMETERS[index][1])\n  )\n  return {\n    request_retention: props?.request_retention || default_request_retention,\n    maximum_interval: props?.maximum_interval || default_maximum_interval,\n    w: w,\n    enable_fuzz: props?.enable_fuzz ?? default_enable_fuzz,\n    enable_short_term: props?.enable_short_term ?? default_enable_short_term,\n  } satisfies FSRSParameters\n}\n\n/**\n * Create an empty card\n * @param now Current time\n * @param afterHandler Convert the result to another type. (Optional)\n * @example\n * ```\n * const card: Card = createEmptyCard(new Date());\n * ```\n * @example\n * ```\n * interface CardUnChecked\n *   extends Omit<Card, \"due\" | \"last_review\" | \"state\"> {\n *   cid: string;\n *   due: Date | number;\n *   last_review: Date | null | number;\n *   state: StateType;\n * }\n *\n * function cardAfterHandler(card: Card) {\n *      return {\n *       ...card,\n *       cid: \"test001\",\n *       state: State[card.state],\n *       last_review: card.last_review ?? null,\n *     } as CardUnChecked;\n * }\n *\n * const card: CardUnChecked = createEmptyCard(new Date(), cardAfterHandler);\n * ```\n */\nexport function createEmptyCard<R = Card>(\n  now?: DateInput,\n  afterHandler?: (card: Card) => R\n): R {\n  const emptyCard: Card = {\n    due: now ? TypeConvert.time(now) : new Date(),\n    stability: 0,\n    difficulty: 0,\n    elapsed_days: 0,\n    scheduled_days: 0,\n    reps: 0,\n    lapses: 0,\n    state: State.New,\n    last_review: undefined,\n  }\n  if (afterHandler && typeof afterHandler === 'function') {\n    return afterHandler(emptyCard)\n  } else {\n    return emptyCard as R\n  }\n}\n","// https://github.com/davidbau/seedrandom/blob/released/lib/alea.js\n// A port of an algorithm by Johannes Baagøe <baagoe@baagoe.com>, 2010\n// http://baagoe.com/en/RandomMusings/javascript/\n// https://github.com/nquinlan/better-random-numbers-for-javascript-mirror\n// Original work is under MIT license -\n\n// Copyright (C) 2010 by Johannes Baagøe <baagoe@baagoe.org>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\ntype State = {\n  c: number\n  s0: number\n  s1: number\n  s2: number\n}\n\nclass Alea {\n  private c: number\n  private s0: number\n  private s1: number\n  private s2: number\n\n  constructor(seed?: number | string) {\n    const mash = Mash()\n    this.c = 1\n    this.s0 = mash(' ')\n    this.s1 = mash(' ')\n    this.s2 = mash(' ')\n    if (seed == null) seed = +new Date()\n    this.s0 -= mash(seed)\n    if (this.s0 < 0) this.s0 += 1\n    this.s1 -= mash(seed)\n    if (this.s1 < 0) this.s1 += 1\n    this.s2 -= mash(seed)\n    if (this.s2 < 0) this.s2 += 1\n  }\n\n  next(): number {\n    const t = 2091639 * this.s0 + this.c * 2.3283064365386963e-10 // 2^-32\n    this.s0 = this.s1\n    this.s1 = this.s2\n    this.s2 = t - (this.c = t | 0)\n    return this.s2\n  }\n\n  set state(state: State) {\n    this.c = state.c\n    this.s0 = state.s0\n    this.s1 = state.s1\n    this.s2 = state.s2\n  }\n\n  get state(): State {\n    return {\n      c: this.c,\n      s0: this.s0,\n      s1: this.s1,\n      s2: this.s2,\n    }\n  }\n}\n\nfunction Mash() {\n  let n = 0xefc8249d\n  return function mash(data: string | number): number {\n    data = String(data)\n    for (let i = 0; i < data.length; i++) {\n      n += data.charCodeAt(i)\n      let h = 0.02519603282416938 * n\n      n = h >>> 0\n      h -= n\n      h *= n\n      n = h >>> 0\n      h -= n\n      n += h * 0x100000000 // 2^32\n    }\n    return (n >>> 0) * 2.3283064365386963e-10 // 2^-32\n  }\n}\n\nfunction alea(seed?: number | string) {\n  const xg = new Alea(seed)\n  const prng = () => xg.next()\n\n  prng.int32 = () => (xg.next() * 0x100000000) | 0\n  prng.double = () =>\n    prng() + ((prng() * 0x200000) | 0) * 1.1102230246251565e-16 // 2^-53\n  prng.state = () => xg.state\n  prng.importState = (state: State) => {\n    xg.state = state\n    return prng\n  }\n  return prng\n}\n\nexport { alea }\n","import { generatorParameters, S_MIN } from './default'\nimport { FSRSParameters, FSRSState, Grade, Rating } from './models'\nimport type { int } from './types'\nimport { clamp, get_fuzz_range } from './help'\nimport { alea } from './alea'\n\n/**\n * @default DECAY = -0.5\n */\nexport const DECAY: number = -0.5\n/**\n * FACTOR = Math.pow(0.9, 1 / DECAY) - 1= 19 / 81\n *\n * $$\\text{FACTOR} = \\frac{19}{81}$$\n * @default FACTOR = 19 / 81\n */\nexport const FACTOR: number = 19 / 81\n\n/**\n * The formula used is :\n * $$R(t,S) = (1 + \\text{FACTOR} \\times \\frac{t}{9 \\cdot S})^{\\text{DECAY}}$$\n * @param {number} elapsed_days t days since the last review\n * @param {number} stability Stability (interval when R=90%)\n * @return {number} r Retrievability (probability of recall)\n */\nexport function forgetting_curve(\n  elapsed_days: number,\n  stability: number\n): number {\n  return +Math.pow(1 + (FACTOR * elapsed_days) / stability, DECAY).toFixed(8)\n}\n\n/**\n * @see https://github.com/open-spaced-repetition/fsrs4anki/wiki/The-Algorithm#fsrs-45\n */\nexport class FSRSAlgorithm {\n  protected param!: FSRSParameters\n  protected intervalModifier!: number\n  protected _seed?: string\n\n  constructor(params: Partial<FSRSParameters>) {\n    this.param = new Proxy(\n      generatorParameters(params),\n      this.params_handler_proxy()\n    )\n    this.intervalModifier = this.calculate_interval_modifier(\n      this.param.request_retention\n    )\n  }\n\n  get interval_modifier(): number {\n    return this.intervalModifier\n  }\n\n  set seed(seed: string) {\n    this._seed = seed\n  }\n\n  /**\n   * @see https://github.com/open-spaced-repetition/fsrs4anki/wiki/The-Algorithm#fsrs-45\n   *\n   * The formula used is: $$I(r,s) = (r^{\\frac{1}{DECAY}} - 1) / FACTOR \\times s$$\n   * @param request_retention 0<request_retention<=1,Requested retention rate\n   * @throws {Error} Requested retention rate should be in the range (0,1]\n   */\n  calculate_interval_modifier(request_retention: number): number {\n    if (request_retention <= 0 || request_retention > 1) {\n      throw new Error('Requested retention rate should be in the range (0,1]')\n    }\n    return +((Math.pow(request_retention, 1 / DECAY) - 1) / FACTOR).toFixed(8)\n  }\n\n  /**\n   * Get the parameters of the algorithm.\n   */\n  get parameters(): FSRSParameters {\n    return this.param\n  }\n\n  /**\n   * Set the parameters of the algorithm.\n   * @param params Partial<FSRSParameters>\n   */\n  set parameters(params: Partial<FSRSParameters>) {\n    this.update_parameters(params)\n  }\n\n  protected params_handler_proxy(): ProxyHandler<FSRSParameters> {\n    const _this = this satisfies FSRSAlgorithm\n    return {\n      set: function (\n        target: FSRSParameters,\n        prop: keyof FSRSParameters,\n        value: FSRSParameters[keyof FSRSParameters]\n      ) {\n        if (prop === 'request_retention' && Number.isFinite(value)) {\n          _this.intervalModifier = _this.calculate_interval_modifier(\n            Number(value)\n          )\n        }\n        Reflect.set(target, prop, value)\n        return true\n      },\n    }\n  }\n\n  private update_parameters(params: Partial<FSRSParameters>): void {\n    const _params = generatorParameters(params)\n    for (const key in _params) {\n      if (key in this.param) {\n        const paramKey = key as keyof FSRSParameters\n        this.param[paramKey] = _params[paramKey] as never\n      }\n    }\n  }\n\n  /**\n   * The formula used is :\n   * $$ S_0(G) = w_{G-1}$$\n   * $$S_0 = \\max \\lbrace S_0,0.1\\rbrace $$\n\n   * @param g Grade (rating at Anki) [1.again,2.hard,3.good,4.easy]\n   * @return Stability (interval when R=90%)\n   */\n  init_stability(g: Grade): number {\n    return Math.max(this.param.w[g - 1], 0.1)\n  }\n\n  /**\n   * The formula used is :\n   * $$D_0(G) = w_4 - e^{(G-1) \\cdot w_5} + 1 $$\n   * $$D_0 = \\min \\lbrace \\max \\lbrace D_0(G),1 \\rbrace,10 \\rbrace$$\n   * where the $$D_0(1)=w_4$$ when the first rating is good.\n   *\n   * @param {Grade} g Grade (rating at Anki) [1.again,2.hard,3.good,4.easy]\n   * @return {number} Difficulty $$D \\in [1,10]$$\n   */\n  init_difficulty(g: Grade): number {\n    return this.constrain_difficulty(\n      this.param.w[4] - Math.exp((g - 1) * this.param.w[5]) + 1\n    )\n  }\n\n  /**\n   * If fuzzing is disabled or ivl is less than 2.5, it returns the original interval.\n   * @param {number} ivl - The interval to be fuzzed.\n   * @param {number} elapsed_days t days since the last review\n   * @return {number} - The fuzzed interval.\n   **/\n  apply_fuzz(ivl: number, elapsed_days: number): int {\n    if (!this.param.enable_fuzz || ivl < 2.5) return Math.round(ivl) as int\n    const generator = alea(this._seed) // I do not want others to directly access the seed externally.\n    const fuzz_factor = generator()\n    const { min_ivl, max_ivl } = get_fuzz_range(\n      ivl,\n      elapsed_days,\n      this.param.maximum_interval\n    )\n    return Math.floor(fuzz_factor * (max_ivl - min_ivl + 1) + min_ivl) as int\n  }\n\n  /**\n   *   @see The formula used is : {@link FSRSAlgorithm.calculate_interval_modifier}\n   *   @param {number} s - Stability (interval when R=90%)\n   *   @param {number} elapsed_days t days since the last review\n   */\n  next_interval(s: number, elapsed_days: number): int {\n    const newInterval = Math.min(\n      Math.max(1, Math.round(s * this.intervalModifier)),\n      this.param.maximum_interval\n    ) as int\n    return this.apply_fuzz(newInterval, elapsed_days)\n  }\n\n  /**\n   * @see https://github.com/open-spaced-repetition/fsrs4anki/issues/697\n   */\n  linear_damping(delta_d: number, old_d: number): number {\n    return +((delta_d * (10 - old_d)) / 9).toFixed(8)\n  }\n\n  /**\n   * The formula used is :\n   * $$\\text{delta}_d = -w_6 \\cdot (g - 3)$$\n   * $$\\text{next}_d = D + \\text{linear damping}(\\text{delta}_d , D)$$\n   * $$D^\\prime(D,R) = w_7 \\cdot D_0(4) +(1 - w_7) \\cdot \\text{next}_d$$\n   * @param {number} d Difficulty $$D \\in [1,10]$$\n   * @param {Grade} g Grade (rating at Anki) [1.again,2.hard,3.good,4.easy]\n   * @return {number} $$\\text{next}_D$$\n   */\n  next_difficulty(d: number, g: Grade): number {\n    const delta_d = -this.param.w[6] * (g - 3)\n    const next_d = d + this.linear_damping(delta_d, d)\n    return this.constrain_difficulty(\n      this.mean_reversion(this.init_difficulty(Rating.Easy), next_d)\n    )\n  }\n\n  /**\n   * The formula used is :\n   * $$\\min \\lbrace \\max \\lbrace D_0,1 \\rbrace,10\\rbrace$$\n   * @param {number} difficulty $$D \\in [1,10]$$\n   */\n  constrain_difficulty(difficulty: number): number {\n    return Math.min(Math.max(+difficulty.toFixed(8), 1), 10)\n  }\n\n  /**\n   * The formula used is :\n   * $$w_7 \\cdot \\text{init} +(1 - w_7) \\cdot \\text{current}$$\n   * @param {number} init $$w_2 : D_0(3) = w_2 + (R-2) \\cdot w_3= w_2$$\n   * @param {number} current $$D - w_6 \\cdot (R - 2)$$\n   * @return {number} difficulty\n   */\n  mean_reversion(init: number, current: number): number {\n    return +(this.param.w[7] * init + (1 - this.param.w[7]) * current).toFixed(\n      8\n    )\n  }\n\n  /**\n   * The formula used is :\n   * $$S^\\prime_r(D,S,R,G) = S\\cdot(e^{w_8}\\cdot (11-D)\\cdot S^{-w_9}\\cdot(e^{w_{10}\\cdot(1-R)}-1)\\cdot w_{15}(\\text{if} G=2) \\cdot w_{16}(\\text{if} G=4)+1)$$\n   * @param {number} d Difficulty D \\in [1,10]\n   * @param {number} s Stability (interval when R=90%)\n   * @param {number} r Retrievability (probability of recall)\n   * @param {Grade} g Grade (Rating[0.again,1.hard,2.good,3.easy])\n   * @return {number} S^\\prime_r new stability after recall\n   */\n  next_recall_stability(d: number, s: number, r: number, g: Grade): number {\n    const hard_penalty = Rating.Hard === g ? this.param.w[15] : 1\n    const easy_bound = Rating.Easy === g ? this.param.w[16] : 1\n    return +clamp(\n      s *\n        (1 +\n          Math.exp(this.param.w[8]) *\n            (11 - d) *\n            Math.pow(s, -this.param.w[9]) *\n            (Math.exp((1 - r) * this.param.w[10]) - 1) *\n            hard_penalty *\n            easy_bound),\n      S_MIN,\n      36500.0\n    ).toFixed(8)\n  }\n\n  /**\n   * The formula used is :\n   * $$S^\\prime_f(D,S,R) = w_{11}\\cdot D^{-w_{12}}\\cdot ((S+1)^{w_{13}}-1) \\cdot e^{w_{14}\\cdot(1-R)}$$\n   * enable_short_term = true : $$S^\\prime_f \\in \\min \\lbrace \\max \\lbrace S^\\prime_f,0.01\\rbrace, \\frac{S}{e^{w_{17} \\cdot w_{18}}} \\rbrace$$\n   * enable_short_term = false : $$S^\\prime_f \\in \\min \\lbrace \\max \\lbrace S^\\prime_f,0.01\\rbrace, S \\rbrace$$\n   * @param {number} d Difficulty D \\in [1,10]\n   * @param {number} s Stability (interval when R=90%)\n   * @param {number} r Retrievability (probability of recall)\n   * @return {number} S^\\prime_f new stability after forgetting\n   */\n  next_forget_stability(d: number, s: number, r: number): number {\n    return +clamp(\n      this.param.w[11] *\n        Math.pow(d, -this.param.w[12]) *\n        (Math.pow(s + 1, this.param.w[13]) - 1) *\n        Math.exp((1 - r) * this.param.w[14]),\n      S_MIN,\n      36500.0\n    ).toFixed(8)\n  }\n\n  /**\n   * The formula used is :\n   * $$S^\\prime_s(S,G) = S \\cdot e^{w_{17} \\cdot (G-3+w_{18})}$$\n   * @param {number} s Stability (interval when R=90%)\n   * @param {Grade} g Grade (Rating[0.again,1.hard,2.good,3.easy])\n   */\n  next_short_term_stability(s: number, g: Grade): number {\n    return +clamp(\n      s * Math.exp(this.param.w[17] * (g - 3 + this.param.w[18])),\n      S_MIN,\n      36500.0\n    ).toFixed(8)\n  }\n\n  forgetting_curve = forgetting_curve\n\n  /**\n   * Calculates the next state of memory based on the current state, time elapsed, and grade.\n   *\n   * @param memory_state - The current state of memory, which can be null.\n   * @param t - The time elapsed since the last review.\n   * @param {Rating} g Grade (Rating[0.Manual,1.Again,2.Hard,3.Good,4.Easy])\n   * @returns The next state of memory with updated difficulty and stability.\n   */\n  next_state(memory_state: FSRSState | null, t: number, g: number): FSRSState {\n    const { difficulty: d, stability: s } = memory_state ?? {\n      difficulty: 0,\n      stability: 0,\n    }\n    if (t < 0) {\n      throw new Error(`Invalid delta_t \"${t}\"`)\n    }\n    if (g < 0 || g > 4) {\n      throw new Error(`Invalid grade \"${g}\"`)\n    }\n    if (d === 0 && s === 0) {\n      return {\n        difficulty: this.init_difficulty(g),\n        stability: this.init_stability(g),\n      }\n    }\n    if (g === 0) {\n      return {\n        difficulty: d,\n        stability: s,\n      }\n    }\n    if (d < 1 || s < S_MIN) {\n      throw new Error(\n        `Invalid memory state { difficulty: ${d}, stability: ${s} }`\n      )\n    }\n    const r = this.forgetting_curve(t, s)\n    const s_after_success = this.next_recall_stability(d, s, r, g)\n    const s_after_fail = this.next_forget_stability(d, s, r)\n    const s_after_short_term = this.next_short_term_stability(s, g)\n    let new_s = s_after_success\n    if (g === 1) {\n      let [w_17, w_18] = [0, 0]\n      if (this.param.enable_short_term) {\n        w_17 = this.param.w[17]\n        w_18 = this.param.w[18]\n      }\n      const next_s_min = s / Math.exp(w_17 * w_18)\n      new_s = clamp(+next_s_min.toFixed(8), S_MIN, s_after_fail)\n    }\n    if (t === 0 && this.param.enable_short_term) {\n      new_s = s_after_short_term\n    }\n\n    const new_d = this.next_difficulty(d, g)\n    return { difficulty: new_d, stability: new_s }\n  }\n}\n","import type { AbstractScheduler } from '../abstract_scheduler'\nimport type { TSeedStrategy } from './types'\n\nexport function DefaultInitSeedStrategy(this: AbstractScheduler): string {\n  const time = this.review_time.getTime()\n  const reps = this.current.reps\n  const mul = this.current.difficulty * this.current.stability\n  return `${time}_${reps}_${mul}`\n}\n\n/**\n * Generates a seed strategy function for card IDs.\n *\n * @param card_id_field - The field name of the card ID in the current object.\n * @returns A function that generates a seed based on the card ID and repetitions.\n *\n * @remarks\n * The returned function uses the `card_id_field` to retrieve the card ID from the current object.\n * It then adds the number of repetitions (`reps`) to the card ID to generate the seed.\n *\n * @example\n * ```typescript\n * const seedStrategy = GenCardIdSeedStrategy('card_id');\n * const f = fsrs().useStrategy(StrategyMode.SEED, seedStrategy)\n * const card = createEmptyCard<Card & { card_id: number }>()\n * card.card_id = 555\n * const record = f.repeat(card, new Date())\n * ```\n */\nexport function GenSeedStrategyWithCardId(\n  card_id_field: string | number\n): TSeedStrategy {\n  return function (this: AbstractScheduler): string {\n    // https://github.com/open-spaced-repetition/ts-fsrs/issues/131#issuecomment-2408426225\n    const card_id = Reflect.get(this.current, card_id_field) ?? 0\n    const reps = this.current.reps\n    // ex1\n    // card_id:string + reps:number = 'e2ecb1f7-8d15-420b-bec4-c7212ad2e5dc' + 4\n    // = 'e2ecb1f7-8d15-420b-bec4-c7212ad2e5dc4'\n\n    // ex2\n    // card_id:number + reps:number = 1732452519198 + 4\n    // = '17324525191984'\n    return String(card_id + reps || 0)\n  }\n}\n","import type { AbstractScheduler } from '../abstract_scheduler'\nimport type { FSRSAlgorithm } from '../algorithm'\nimport type { Card, CardInput, DateInput } from '../models'\nimport type { IScheduler } from '../types'\n\nexport enum StrategyMode {\n  SCHEDULER = 'Scheduler',\n  SEED = 'Seed',\n}\n\nexport type TSeedStrategy = (this: AbstractScheduler) => string\nexport type TSchedulerStrategy<T extends CardInput | Card = CardInput | Card> =\n  new (\n    card: T,\n    now: DateInput,\n    algorithm: FSRSAlgorithm,\n    strategies: { seed: TSeedStrategy }\n  ) => IScheduler\n\nexport type TStrategyHandler<E = StrategyMode> =\n  E extends StrategyMode.SCHEDULER\n    ? TSchedulerStrategy\n    : E extends StrategyMode.SEED\n      ? TSeedStrategy\n      : never\n","import { FSRSAlgorithm } from './algorithm'\nimport { TypeConvert } from './convert'\nimport { dateDiffInDays, Grades } from './help'\nimport {\n  type Card,\n  type Grade,\n  type RecordLogItem,\n  State,\n  Rating,\n  type ReviewLog,\n  type CardInput,\n  type DateInput,\n} from './models'\nimport { DefaultInitSeedStrategy } from './strategies'\nimport type { TSeedStrategy } from './strategies/types'\nimport type { IPreview, IScheduler } from './types'\n\nexport abstract class AbstractScheduler implements IScheduler {\n  protected last: Card\n  protected current: Card\n  protected review_time: Date\n  protected next: Map<Grade, RecordLogItem> = new Map()\n  protected algorithm: FSRSAlgorithm\n  private initSeedStrategy: TSeedStrategy\n\n  constructor(\n    card: CardInput | Card,\n    now: DateInput,\n    algorithm: FSRSAlgorithm,\n    strategies: {\n      seed: TSeedStrategy\n    } = {\n      seed: DefaultInitSeedStrategy,\n    }\n  ) {\n    this.algorithm = algorithm\n    this.initSeedStrategy = strategies.seed.bind(this)\n\n    this.last = TypeConvert.card(card)\n    this.current = TypeConvert.card(card)\n    this.review_time = TypeConvert.time(now)\n    this.init()\n  }\n\n  private init() {\n    const { state, last_review } = this.current\n    let interval = 0 // card.state === State.New => 0\n    if (state !== State.New && last_review) {\n      interval = dateDiffInDays(last_review, this.review_time)\n    }\n    this.current.last_review = this.review_time\n    this.current.elapsed_days = interval\n    this.current.reps += 1\n    this.algorithm.seed = this.initSeedStrategy()\n  }\n\n  public preview(): IPreview {\n    return {\n      [Rating.Again]: this.review(Rating.Again),\n      [Rating.Hard]: this.review(Rating.Hard),\n      [Rating.Good]: this.review(Rating.Good),\n      [Rating.Easy]: this.review(Rating.Easy),\n      [Symbol.iterator]: this.previewIterator.bind(this),\n    } satisfies IPreview\n  }\n\n  private *previewIterator(): IterableIterator<RecordLogItem> {\n    for (const grade of Grades) {\n      yield this.review(grade)\n    }\n  }\n\n  public review(grade: Grade): RecordLogItem {\n    const { state } = this.last\n    let item: RecordLogItem | undefined\n    switch (state) {\n      case State.New:\n        item = this.newState(grade)\n        break\n      case State.Learning:\n      case State.Relearning:\n        item = this.learningState(grade)\n        break\n      case State.Review:\n        item = this.reviewState(grade)\n        break\n    }\n    if (item) {\n      return item\n    }\n    throw new Error('Invalid grade')\n  }\n\n  protected abstract newState(grade: Grade): RecordLogItem\n\n  protected abstract learningState(grade: Grade): RecordLogItem\n\n  protected abstract reviewState(grade: Grade): RecordLogItem\n\n  protected buildLog(rating: Grade): ReviewLog {\n    const { last_review, due, elapsed_days } = this.last\n\n    return {\n      rating: rating,\n      state: this.current.state,\n      due: last_review || due,\n      stability: this.current.stability,\n      difficulty: this.current.difficulty,\n      elapsed_days: this.current.elapsed_days,\n      last_elapsed_days: elapsed_days,\n      scheduled_days: this.current.scheduled_days,\n      review: this.review_time,\n    } satisfies ReviewLog\n  }\n}\n","import { AbstractScheduler } from '../abstract_scheduler'\nimport { TypeConvert } from '../convert'\nimport { S_MIN } from '../default'\nimport { clamp } from '../help'\nimport {\n  type Card,\n  type Grade,\n  Rating,\n  type RecordLogItem,\n  State,\n} from '../models'\nimport type { int } from '../types'\n\nexport default class BasicScheduler extends AbstractScheduler {\n  protected override newState(grade: Grade): RecordLogItem {\n    const exist = this.next.get(grade)\n    if (exist) {\n      return exist\n    }\n    const next = TypeConvert.card(this.current)\n    next.difficulty = this.algorithm.init_difficulty(grade)\n    next.stability = this.algorithm.init_stability(grade)\n\n    switch (grade) {\n      case Rating.Again:\n        next.scheduled_days = 0\n        next.due = this.review_time.scheduler(1 as int)\n        next.state = State.Learning\n        break\n      case Rating.Hard:\n        next.scheduled_days = 0\n        next.due = this.review_time.scheduler(5 as int)\n        next.state = State.Learning\n        break\n      case Rating.Good:\n        next.scheduled_days = 0\n        next.due = this.review_time.scheduler(10 as int)\n        next.state = State.Learning\n        break\n      case Rating.Easy: {\n        const easy_interval = this.algorithm.next_interval(\n          next.stability,\n          this.current.elapsed_days\n        )\n        next.scheduled_days = easy_interval\n        next.due = this.review_time.scheduler(easy_interval as int, true)\n        next.state = State.Review\n        break\n      }\n      default:\n        throw new Error('Invalid grade')\n    }\n    const item = {\n      card: next,\n      log: this.buildLog(grade),\n    } satisfies RecordLogItem\n    this.next.set(grade, item)\n    return item\n  }\n\n  protected override learningState(grade: Grade): RecordLogItem {\n    const exist = this.next.get(grade)\n    if (exist) {\n      return exist\n    }\n    const { state, difficulty, stability } = this.last\n    const next = TypeConvert.card(this.current)\n    const interval = this.current.elapsed_days\n    next.difficulty = this.algorithm.next_difficulty(difficulty, grade)\n    next.stability = this.algorithm.next_short_term_stability(stability, grade)\n\n    switch (grade) {\n      case Rating.Again: {\n        next.scheduled_days = 0\n        next.due = this.review_time.scheduler(5 as int, false)\n        next.state = state\n        break\n      }\n      case Rating.Hard: {\n        next.scheduled_days = 0\n        next.due = this.review_time.scheduler(10 as int)\n        next.state = state\n        break\n      }\n      case Rating.Good: {\n        const good_interval = this.algorithm.next_interval(\n          next.stability,\n          interval\n        )\n        next.scheduled_days = good_interval\n        next.due = this.review_time.scheduler(good_interval as int, true)\n        next.state = State.Review\n        break\n      }\n      case Rating.Easy: {\n        const good_stability = this.algorithm.next_short_term_stability(\n          stability,\n          Rating.Good\n        )\n        const good_interval = this.algorithm.next_interval(\n          good_stability,\n          interval\n        )\n        const easy_interval = Math.max(\n          this.algorithm.next_interval(next.stability, interval),\n          good_interval + 1\n        ) as int\n        next.scheduled_days = easy_interval\n        next.due = this.review_time.scheduler(easy_interval as int, true)\n        next.state = State.Review\n        break\n      }\n      default:\n        throw new Error('Invalid grade')\n    }\n    const item = {\n      card: next,\n      log: this.buildLog(grade),\n    } satisfies RecordLogItem\n    this.next.set(grade, item)\n    return item\n  }\n\n  protected override reviewState(grade: Grade): RecordLogItem {\n    const exist = this.next.get(grade)\n    if (exist) {\n      return exist\n    }\n    const interval = this.current.elapsed_days\n    const { difficulty, stability } = this.last\n    const retrievability = this.algorithm.forgetting_curve(interval, stability)\n    const next_again = TypeConvert.card(this.current)\n    const next_hard = TypeConvert.card(this.current)\n    const next_good = TypeConvert.card(this.current)\n    const next_easy = TypeConvert.card(this.current)\n\n    this.next_ds(\n      next_again,\n      next_hard,\n      next_good,\n      next_easy,\n      difficulty,\n      stability,\n      retrievability\n    )\n\n    this.next_interval(next_again, next_hard, next_good, next_easy, interval)\n    this.next_state(next_again, next_hard, next_good, next_easy)\n    next_again.lapses += 1\n\n    const item_again = {\n      card: next_again,\n      log: this.buildLog(Rating.Again),\n    } satisfies RecordLogItem\n    const item_hard = {\n      card: next_hard,\n      log: super.buildLog(Rating.Hard),\n    } satisfies RecordLogItem\n    const item_good = {\n      card: next_good,\n      log: super.buildLog(Rating.Good),\n    } satisfies RecordLogItem\n    const item_easy = {\n      card: next_easy,\n      log: super.buildLog(Rating.Easy),\n    } satisfies RecordLogItem\n\n    this.next.set(Rating.Again, item_again)\n    this.next.set(Rating.Hard, item_hard)\n    this.next.set(Rating.Good, item_good)\n    this.next.set(Rating.Easy, item_easy)\n    return this.next.get(grade)!\n  }\n\n  /**\n   * Review next_ds\n   */\n  private next_ds(\n    next_again: Card,\n    next_hard: Card,\n    next_good: Card,\n    next_easy: Card,\n    difficulty: number,\n    stability: number,\n    retrievability: number\n  ): void {\n    next_again.difficulty = this.algorithm.next_difficulty(\n      difficulty,\n      Rating.Again\n    )\n    const nextSMin =\n      stability /\n      Math.exp(\n        this.algorithm.parameters.w[17] * this.algorithm.parameters.w[18]\n      )\n    const s_after_fail = this.algorithm.next_forget_stability(\n      difficulty,\n      stability,\n      retrievability\n    )\n    next_again.stability = clamp(+nextSMin.toFixed(8), S_MIN, s_after_fail)\n\n    next_hard.difficulty = this.algorithm.next_difficulty(\n      difficulty,\n      Rating.Hard\n    )\n    next_hard.stability = this.algorithm.next_recall_stability(\n      difficulty,\n      stability,\n      retrievability,\n      Rating.Hard\n    )\n    next_good.difficulty = this.algorithm.next_difficulty(\n      difficulty,\n      Rating.Good\n    )\n    next_good.stability = this.algorithm.next_recall_stability(\n      difficulty,\n      stability,\n      retrievability,\n      Rating.Good\n    )\n    next_easy.difficulty = this.algorithm.next_difficulty(\n      difficulty,\n      Rating.Easy\n    )\n    next_easy.stability = this.algorithm.next_recall_stability(\n      difficulty,\n      stability,\n      retrievability,\n      Rating.Easy\n    )\n  }\n\n  /**\n   * Review next_interval\n   */\n  private next_interval(\n    next_again: Card,\n    next_hard: Card,\n    next_good: Card,\n    next_easy: Card,\n    interval: number\n  ): void {\n    let hard_interval: int, good_interval: int\n    hard_interval = this.algorithm.next_interval(next_hard.stability, interval)\n    good_interval = this.algorithm.next_interval(next_good.stability, interval)\n    hard_interval = Math.min(hard_interval, good_interval) as int\n    good_interval = Math.max(good_interval, hard_interval + 1) as int\n    const easy_interval = Math.max(\n      this.algorithm.next_interval(next_easy.stability, interval),\n      good_interval + 1\n    ) as int\n    next_again.scheduled_days = 0\n    next_again.due = this.review_time.scheduler(5 as int)\n\n    next_hard.scheduled_days = hard_interval\n    next_hard.due = this.review_time.scheduler(hard_interval, true)\n    next_good.scheduled_days = good_interval\n    next_good.due = this.review_time.scheduler(good_interval, true)\n\n    next_easy.scheduled_days = easy_interval\n    next_easy.due = this.review_time.scheduler(easy_interval, true)\n  }\n\n  /**\n   * Review next_state\n   */\n  private next_state(\n    next_again: Card,\n    next_hard: Card,\n    next_good: Card,\n    next_easy: Card\n  ) {\n    next_again.state = State.Relearning\n    // next_again.lapses += 1\n\n    next_hard.state = State.Review\n\n    next_good.state = State.Review\n\n    next_easy.state = State.Review\n  }\n}\n","import { AbstractScheduler } from '../abstract_scheduler'\nimport { TypeConvert } from '../convert'\nimport { S_MIN } from '../default'\nimport { clamp } from '../help'\nimport {\n  type Card,\n  type Grade,\n  Rating,\n  type RecordLogItem,\n  State,\n} from '../models'\nimport type { int } from '../types'\n\nexport default class LongTermScheduler extends AbstractScheduler {\n  protected override newState(grade: Grade): RecordLogItem {\n    const exist = this.next.get(grade)\n    if (exist) {\n      return exist\n    }\n\n    this.current.scheduled_days = 0\n    this.current.elapsed_days = 0\n\n    const next_again = TypeConvert.card(this.current)\n    const next_hard = TypeConvert.card(this.current)\n    const next_good = TypeConvert.card(this.current)\n    const next_easy = TypeConvert.card(this.current)\n\n    this.init_ds(next_again, next_hard, next_good, next_easy)\n    const first_interval = 0\n\n    this.next_interval(\n      next_again,\n      next_hard,\n      next_good,\n      next_easy,\n      first_interval\n    )\n\n    this.next_state(next_again, next_hard, next_good, next_easy)\n    this.update_next(next_again, next_hard, next_good, next_easy)\n    return this.next.get(grade)!\n  }\n\n  private init_ds(\n    next_again: Card,\n    next_hard: Card,\n    next_good: Card,\n    next_easy: Card\n  ): void {\n    next_again.difficulty = this.algorithm.init_difficulty(Rating.Again)\n    next_again.stability = this.algorithm.init_stability(Rating.Again)\n\n    next_hard.difficulty = this.algorithm.init_difficulty(Rating.Hard)\n    next_hard.stability = this.algorithm.init_stability(Rating.Hard)\n\n    next_good.difficulty = this.algorithm.init_difficulty(Rating.Good)\n    next_good.stability = this.algorithm.init_stability(Rating.Good)\n\n    next_easy.difficulty = this.algorithm.init_difficulty(Rating.Easy)\n    next_easy.stability = this.algorithm.init_stability(Rating.Easy)\n  }\n\n  /**\n   * @see https://github.com/open-spaced-repetition/ts-fsrs/issues/98#issuecomment-2241923194\n   */\n  protected override learningState(grade: Grade): RecordLogItem {\n    return this.reviewState(grade)\n  }\n  protected override reviewState(grade: Grade): RecordLogItem {\n    const exist = this.next.get(grade)\n    if (exist) {\n      return exist\n    }\n    const interval = this.current.elapsed_days\n    const { difficulty, stability } = this.last\n    const retrievability = this.algorithm.forgetting_curve(interval, stability)\n    const next_again = TypeConvert.card(this.current)\n    const next_hard = TypeConvert.card(this.current)\n    const next_good = TypeConvert.card(this.current)\n    const next_easy = TypeConvert.card(this.current)\n\n    this.next_ds(\n      next_again,\n      next_hard,\n      next_good,\n      next_easy,\n      difficulty,\n      stability,\n      retrievability\n    )\n\n    this.next_interval(next_again, next_hard, next_good, next_easy, interval)\n    this.next_state(next_again, next_hard, next_good, next_easy)\n    next_again.lapses += 1\n\n    this.update_next(next_again, next_hard, next_good, next_easy)\n    return this.next.get(grade)!\n  }\n\n  /**\n   * Review next_ds\n   */\n  private next_ds(\n    next_again: Card,\n    next_hard: Card,\n    next_good: Card,\n    next_easy: Card,\n    difficulty: number,\n    stability: number,\n    retrievability: number\n  ): void {\n    next_again.difficulty = this.algorithm.next_difficulty(\n      difficulty,\n      Rating.Again\n    )\n    const s_after_fail = this.algorithm.next_forget_stability(\n      difficulty,\n      stability,\n      retrievability\n    )\n    next_again.stability = clamp(stability, S_MIN, s_after_fail)\n\n    next_hard.difficulty = this.algorithm.next_difficulty(\n      difficulty,\n      Rating.Hard\n    )\n    next_hard.stability = this.algorithm.next_recall_stability(\n      difficulty,\n      stability,\n      retrievability,\n      Rating.Hard\n    )\n    next_good.difficulty = this.algorithm.next_difficulty(\n      difficulty,\n      Rating.Good\n    )\n    next_good.stability = this.algorithm.next_recall_stability(\n      difficulty,\n      stability,\n      retrievability,\n      Rating.Good\n    )\n    next_easy.difficulty = this.algorithm.next_difficulty(\n      difficulty,\n      Rating.Easy\n    )\n    next_easy.stability = this.algorithm.next_recall_stability(\n      difficulty,\n      stability,\n      retrievability,\n      Rating.Easy\n    )\n  }\n\n  /**\n   * Review/New next_interval\n   */\n  private next_interval(\n    next_again: Card,\n    next_hard: Card,\n    next_good: Card,\n    next_easy: Card,\n    interval: number\n  ): void {\n    let again_interval: int,\n      hard_interval: int,\n      good_interval: int,\n      easy_interval: int\n    again_interval = this.algorithm.next_interval(\n      next_again.stability,\n      interval\n    )\n    hard_interval = this.algorithm.next_interval(next_hard.stability, interval)\n    good_interval = this.algorithm.next_interval(next_good.stability, interval)\n    easy_interval = this.algorithm.next_interval(next_easy.stability, interval)\n\n    again_interval = Math.min(again_interval, hard_interval) as int\n    hard_interval = Math.max(hard_interval, again_interval + 1) as int\n    good_interval = Math.max(good_interval, hard_interval + 1) as int\n    easy_interval = Math.max(easy_interval, good_interval + 1) as int\n\n    next_again.scheduled_days = again_interval\n    next_again.due = this.review_time.scheduler(again_interval, true)\n\n    next_hard.scheduled_days = hard_interval\n    next_hard.due = this.review_time.scheduler(hard_interval, true)\n\n    next_good.scheduled_days = good_interval\n    next_good.due = this.review_time.scheduler(good_interval, true)\n\n    next_easy.scheduled_days = easy_interval\n    next_easy.due = this.review_time.scheduler(easy_interval, true)\n  }\n\n  /**\n   * Review/New next_state\n   */\n  private next_state(\n    next_again: Card,\n    next_hard: Card,\n    next_good: Card,\n    next_easy: Card\n  ) {\n    next_again.state = State.Review\n    // next_again.lapses += 1\n\n    next_hard.state = State.Review\n\n    next_good.state = State.Review\n\n    next_easy.state = State.Review\n  }\n\n  private update_next(\n    next_again: Card,\n    next_hard: Card,\n    next_good: Card,\n    next_easy: Card\n  ) {\n    const item_again = {\n      card: next_again,\n      log: this.buildLog(Rating.Again),\n    } satisfies RecordLogItem\n    const item_hard = {\n      card: next_hard,\n      log: super.buildLog(Rating.Hard),\n    } satisfies RecordLogItem\n    const item_good = {\n      card: next_good,\n      log: super.buildLog(Rating.Good),\n    } satisfies RecordLogItem\n    const item_easy = {\n      card: next_easy,\n      log: super.buildLog(Rating.Easy),\n    } satisfies RecordLogItem\n\n    this.next.set(Rating.Again, item_again)\n    this.next.set(Rating.Hard, item_hard)\n    this.next.set(Rating.Good, item_good)\n    this.next.set(Rating.Easy, item_easy)\n  }\n}\n","import { TypeConvert } from './convert'\nimport { createEmptyCard } from './default'\nimport type { FSRS } from './fsrs'\nimport {\n  type Card,\n  type CardInput,\n  DateInput,\n  type FSRSHistory,\n  type Grade,\n  Rating,\n  type RecordLogItem,\n  type ReviewLog,\n  State,\n} from './models'\n\n/**\n * The `Reschedule` class provides methods to handle the rescheduling of cards based on their review history.\n * determine the next review dates and update the card's state accordingly.\n */\nexport class Reschedule {\n  private fsrs: FSRS\n  /**\n   * Creates an instance of the `Reschedule` class.\n   * @param fsrs - An instance of the FSRS class used for scheduling.\n   */\n  constructor(fsrs: FSRS) {\n    this.fsrs = fsrs\n  }\n\n  /**\n   * Replays a review for a card and determines the next review date based on the given rating.\n   * @param card - The card being reviewed.\n   * @param reviewed - The date the card was reviewed.\n   * @param rating - The grade given to the card during the review.\n   * @returns A `RecordLogItem` containing the updated card and review log.\n   */\n  replay(card: Card, reviewed: Date, rating: Grade): RecordLogItem {\n    return this.fsrs.next(card, reviewed, rating)\n  }\n\n  /**\n   * Processes a manual review for a card, allowing for custom state, stability, difficulty, and due date.\n   * @param card - The card being reviewed.\n   * @param state - The state of the card after the review.\n   * @param reviewed - The date the card was reviewed.\n   * @param elapsed_days - The number of days since the last review.\n   * @param stability - (Optional) The stability of the card.\n   * @param difficulty - (Optional) The difficulty of the card.\n   * @param due - (Optional) The due date for the next review.\n   * @returns A `RecordLogItem` containing the updated card and review log.\n   * @throws Will throw an error if the state or due date is not provided when required.\n   */\n  handleManualRating(\n    card: Card,\n    state: State,\n    reviewed: Date,\n    elapsed_days: number,\n    stability?: number,\n    difficulty?: number,\n    due?: Date\n  ): RecordLogItem {\n    if (typeof state === 'undefined') {\n      throw new Error('reschedule: state is required for manual rating')\n    }\n    let log: ReviewLog\n    let next_card: Card\n    if (<State>state === State.New) {\n      log = {\n        rating: Rating.Manual,\n        state: state,\n        due: <Date>due ?? reviewed,\n        stability: card.stability,\n        difficulty: card.difficulty,\n        elapsed_days: elapsed_days,\n        last_elapsed_days: card.elapsed_days,\n        scheduled_days: card.scheduled_days,\n        review: <Date>reviewed,\n      } satisfies ReviewLog\n      next_card = createEmptyCard<Card>(reviewed)\n      next_card.last_review = reviewed\n    } else {\n      if (typeof due === 'undefined') {\n        throw new Error('reschedule: due is required for manual rating')\n      }\n      const scheduled_days = due.diff(reviewed as Date, 'days')\n      log = {\n        rating: Rating.Manual,\n        state: <State>card.state,\n        due: card.last_review || card.due,\n        stability: card.stability,\n        difficulty: card.difficulty,\n        elapsed_days: elapsed_days,\n        last_elapsed_days: card.elapsed_days,\n        scheduled_days: card.scheduled_days,\n        review: <Date>reviewed,\n      } satisfies ReviewLog\n      next_card = {\n        ...card,\n        state: <State>state,\n        due: <Date>due,\n        last_review: <Date>reviewed,\n        stability: stability || card.stability,\n        difficulty: difficulty || card.difficulty,\n        elapsed_days: elapsed_days,\n        scheduled_days: scheduled_days,\n        reps: card.reps + 1,\n      } satisfies Card\n    }\n\n    return { card: next_card, log }\n  }\n\n  /**\n   * Reschedules a card based on its review history.\n   *\n   * @param current_card - The card to be rescheduled.\n   * @param reviews - An array of review history objects.\n   * @returns An array of record log items representing the rescheduling process.\n   */\n  reschedule(current_card: CardInput, reviews: FSRSHistory[]) {\n    const collections: RecordLogItem[] = []\n    let cur_card = createEmptyCard<Card>(current_card.due)\n    for (const review of reviews) {\n      let item: RecordLogItem\n      review.review = TypeConvert.time(review.review)\n      if (review.rating === Rating.Manual) {\n        // ref: abstract_scheduler.ts#init\n        let interval = 0\n        if (cur_card.state !== State.New && cur_card.last_review) {\n          interval = review.review.diff(cur_card.last_review as Date, 'days')\n        }\n        item = this.handleManualRating(\n          cur_card,\n          review.state,\n          review.review,\n          interval,\n          review.stability,\n          review.difficulty,\n          review.due ? TypeConvert.time(review.due) : undefined\n        )\n      } else {\n        item = this.replay(cur_card, review.review, review.rating)\n      }\n      collections.push(item)\n      cur_card = item.card\n    }\n    return collections\n  }\n\n  calculateManualRecord(\n    current_card: CardInput,\n    now: DateInput,\n    record_log_item?: RecordLogItem,\n    update_memory?: boolean\n  ): RecordLogItem | null {\n    if (!record_log_item) {\n      return null\n    }\n    // if first_card === recordItem.card then return null\n    const { card: reschedule_card, log } = record_log_item\n    const cur_card = <Card>TypeConvert.card(current_card) // copy card\n    if (cur_card.due.getTime() === reschedule_card.due.getTime()) {\n      return null\n    }\n    cur_card.scheduled_days = reschedule_card.due.diff(\n      cur_card.due as Date,\n      'days'\n    )\n    return this.handleManualRating(\n      cur_card,\n      reschedule_card.state,\n      TypeConvert.time(now),\n      log.elapsed_days,\n      update_memory ? reschedule_card.stability : undefined,\n      update_memory ? reschedule_card.difficulty : undefined,\n      reschedule_card.due\n    )\n  }\n}\n","import {\n  Card,\n  CardInput,\n  DateInput,\n  FSRSHistory,\n  FSRSParameters,\n  Grade,\n  Rating,\n  RecordLogItem,\n  ReviewLog,\n  ReviewLogInput,\n  State,\n} from './models'\nimport {\n  type IPreview,\n  type IReschedule,\n  type RescheduleOptions,\n  type IScheduler,\n} from './types'\nimport { FSRSAlgorithm } from './algorithm'\nimport { TypeConvert } from './convert'\nimport BasicScheduler from './impl/basic_scheduler'\nimport LongTermScheduler from './impl/long_term_scheduler'\nimport { createEmptyCard } from './default'\nimport { Reschedule } from './reschedule'\nimport { DefaultInitSeedStrategy } from './strategies/seed'\nimport {\n  StrategyMode,\n  type TSeedStrategy,\n  type TSchedulerStrategy,\n  type TStrategyHandler,\n} from './strategies/types'\n\nexport class FSRS extends FSRSAlgorithm {\n  private strategyHandler = new Map<StrategyMode, TStrategyHandler>()\n  private Scheduler: TSchedulerStrategy\n  constructor(param: Partial<FSRSParameters>) {\n    super(param)\n    const { enable_short_term } = this.parameters\n    this.Scheduler = enable_short_term ? BasicScheduler : LongTermScheduler\n  }\n\n  protected override params_handler_proxy(): ProxyHandler<FSRSParameters> {\n    const _this = this satisfies FSRS\n    return {\n      set: function (\n        target: FSRSParameters,\n        prop: keyof FSRSParameters,\n        value: FSRSParameters[keyof FSRSParameters]\n      ) {\n        if (prop === 'request_retention' && Number.isFinite(value)) {\n          _this.intervalModifier = _this.calculate_interval_modifier(\n            Number(value)\n          )\n        } else if (prop === 'enable_short_term') {\n          _this.Scheduler = value === true ? BasicScheduler : LongTermScheduler\n        }\n        Reflect.set(target, prop, value)\n        return true\n      },\n    }\n  }\n\n  useStrategy<T extends StrategyMode>(\n    mode: T,\n    handler: TStrategyHandler<T>\n  ): this {\n    this.strategyHandler.set(mode, handler)\n    return this\n  }\n\n  clearStrategy(mode?: StrategyMode): this {\n    if (mode) {\n      this.strategyHandler.delete(mode)\n    } else {\n      this.strategyHandler.clear()\n    }\n    return this\n  }\n\n  private getScheduler(card: CardInput | Card, now: DateInput): IScheduler {\n    const seedStrategy = this.strategyHandler.get(StrategyMode.SEED) as\n      | TSeedStrategy\n      | undefined\n\n    // Strategy scheduler\n    const schedulerStrategy = this.strategyHandler.get(\n      StrategyMode.SCHEDULER\n    ) as TSchedulerStrategy | undefined\n\n    const Scheduler = schedulerStrategy || this.Scheduler\n    const Seed = seedStrategy || DefaultInitSeedStrategy\n    const instance = new Scheduler(card, now, this, {\n      seed: Seed,\n    })\n\n    return instance\n  }\n\n  /**\n   * Display the collection of cards and logs for the four scenarios after scheduling the card at the current time.\n   * @param card Card to be processed\n   * @param now Current time or scheduled time\n   * @param afterHandler Convert the result to another type. (Optional)\n   * @example\n   * ```\n   * const card: Card = createEmptyCard(new Date());\n   * const f = fsrs();\n   * const recordLog = f.repeat(card, new Date());\n   * ```\n   * @example\n   * ```\n   * interface RevLogUnchecked\n   *   extends Omit<ReviewLog, \"due\" | \"review\" | \"state\" | \"rating\"> {\n   *   cid: string;\n   *   due: Date | number;\n   *   state: StateType;\n   *   review: Date | number;\n   *   rating: RatingType;\n   * }\n   *\n   * interface RepeatRecordLog {\n   *   card: CardUnChecked; //see method: createEmptyCard\n   *   log: RevLogUnchecked;\n   * }\n   *\n   * function repeatAfterHandler(recordLog: RecordLog) {\n   *     const record: { [key in Grade]: RepeatRecordLog } = {} as {\n   *       [key in Grade]: RepeatRecordLog;\n   *     };\n   *     for (const grade of Grades) {\n   *       record[grade] = {\n   *         card: {\n   *           ...(recordLog[grade].card as Card & { cid: string }),\n   *           due: recordLog[grade].card.due.getTime(),\n   *           state: State[recordLog[grade].card.state] as StateType,\n   *           last_review: recordLog[grade].card.last_review\n   *             ? recordLog[grade].card.last_review!.getTime()\n   *             : null,\n   *         },\n   *         log: {\n   *           ...recordLog[grade].log,\n   *           cid: (recordLog[grade].card as Card & { cid: string }).cid,\n   *           due: recordLog[grade].log.due.getTime(),\n   *           review: recordLog[grade].log.review.getTime(),\n   *           state: State[recordLog[grade].log.state] as StateType,\n   *           rating: Rating[recordLog[grade].log.rating] as RatingType,\n   *         },\n   *       };\n   *     }\n   *     return record;\n   * }\n   * const card: Card = createEmptyCard(new Date(), cardAfterHandler); //see method:  createEmptyCard\n   * const f = fsrs();\n   * const recordLog = f.repeat(card, new Date(), repeatAfterHandler);\n   * ```\n   */\n  repeat<R = IPreview>(\n    card: CardInput | Card,\n    now: DateInput,\n    afterHandler?: (recordLog: IPreview) => R\n  ): R {\n    const instance = this.getScheduler(card, now)\n    const recordLog = instance.preview()\n    if (afterHandler && typeof afterHandler === 'function') {\n      return afterHandler(recordLog)\n    } else {\n      return recordLog as R\n    }\n  }\n\n  /**\n   * Display the collection of cards and logs for the card scheduled at the current time, after applying a specific grade rating.\n   * @param card Card to be processed\n   * @param now Current time or scheduled time\n   * @param grade Rating of the review (Again, Hard, Good, Easy)\n   * @param afterHandler Convert the result to another type. (Optional)\n   * @example\n   * ```\n   * const card: Card = createEmptyCard(new Date());\n   * const f = fsrs();\n   * const recordLogItem = f.next(card, new Date(), Rating.Again);\n   * ```\n   * @example\n   * ```\n   * interface RevLogUnchecked\n   *   extends Omit<ReviewLog, \"due\" | \"review\" | \"state\" | \"rating\"> {\n   *   cid: string;\n   *   due: Date | number;\n   *   state: StateType;\n   *   review: Date | number;\n   *   rating: RatingType;\n   * }\n   *\n   * interface NextRecordLog {\n   *   card: CardUnChecked; //see method: createEmptyCard\n   *   log: RevLogUnchecked;\n   * }\n   *\n  function nextAfterHandler(recordLogItem: RecordLogItem) {\n    const recordItem = {\n      card: {\n        ...(recordLogItem.card as Card & { cid: string }),\n        due: recordLogItem.card.due.getTime(),\n        state: State[recordLogItem.card.state] as StateType,\n        last_review: recordLogItem.card.last_review\n          ? recordLogItem.card.last_review!.getTime()\n          : null,\n      },\n      log: {\n        ...recordLogItem.log,\n        cid: (recordLogItem.card as Card & { cid: string }).cid,\n        due: recordLogItem.log.due.getTime(),\n        review: recordLogItem.log.review.getTime(),\n        state: State[recordLogItem.log.state] as StateType,\n        rating: Rating[recordLogItem.log.rating] as RatingType,\n      },\n    };\n    return recordItem\n  }\n   * const card: Card = createEmptyCard(new Date(), cardAfterHandler); //see method:  createEmptyCard\n   * const f = fsrs();\n   * const recordLogItem = f.repeat(card, new Date(), Rating.Again, nextAfterHandler);\n   * ```\n   */\n  next<R = RecordLogItem>(\n    card: CardInput | Card,\n    now: DateInput,\n    grade: Grade,\n    afterHandler?: (recordLog: RecordLogItem) => R\n  ): R {\n    const instance = this.getScheduler(card, now)\n    const g = TypeConvert.rating(grade)\n    if (g === Rating.Manual) {\n      throw new Error('Cannot review a manual rating')\n    }\n    const recordLogItem = instance.review(g)\n    if (afterHandler && typeof afterHandler === 'function') {\n      return afterHandler(recordLogItem)\n    } else {\n      return recordLogItem as R\n    }\n  }\n\n  /**\n   * Get the retrievability of the card\n   * @param card  Card to be processed\n   * @param now  Current time or scheduled time\n   * @param format  default:true , Convert the result to another type. (Optional)\n   * @returns  The retrievability of the card,if format is true, the result is a string, otherwise it is a number\n   */\n  get_retrievability<T extends boolean>(\n    card: CardInput | Card,\n    now?: DateInput,\n    format: T = true as T\n  ): T extends true ? string : number {\n    const processedCard = TypeConvert.card(card)\n    now = now ? TypeConvert.time(now) : new Date()\n    const t =\n      processedCard.state !== State.New\n        ? Math.max(now.diff(processedCard.last_review as Date, 'days'), 0)\n        : 0\n    const r =\n      processedCard.state !== State.New\n        ? this.forgetting_curve(t, +processedCard.stability.toFixed(8))\n        : 0\n    return (format ? `${(r * 100).toFixed(2)}%` : r) as T extends true\n      ? string\n      : number\n  }\n\n  /**\n   *\n   * @param card Card to be processed\n   * @param log last review log\n   * @param afterHandler Convert the result to another type. (Optional)\n   * @example\n   * ```\n   * const now = new Date();\n   * const f = fsrs();\n   * const emptyCardFormAfterHandler = createEmptyCard(now);\n   * const repeatFormAfterHandler = f.repeat(emptyCardFormAfterHandler, now);\n   * const { card, log } = repeatFormAfterHandler[Rating.Hard];\n   * const rollbackFromAfterHandler = f.rollback(card, log);\n   * ```\n   *\n   * @example\n   * ```\n   * const now = new Date();\n   * const f = fsrs();\n   * const emptyCardFormAfterHandler = createEmptyCard(now, cardAfterHandler);  //see method: createEmptyCard\n   * const repeatFormAfterHandler = f.repeat(emptyCardFormAfterHandler, now, repeatAfterHandler); //see method: fsrs.repeat()\n   * const { card, log } = repeatFormAfterHandler[Rating.Hard];\n   * const rollbackFromAfterHandler = f.rollback(card, log, cardAfterHandler);\n   * ```\n   */\n  rollback<R = Card>(\n    card: CardInput | Card,\n    log: ReviewLogInput,\n    afterHandler?: (prevCard: Card) => R\n  ): R {\n    const processedCard = TypeConvert.card(card)\n    const processedLog = TypeConvert.review_log(log)\n    if (processedLog.rating === Rating.Manual) {\n      throw new Error('Cannot rollback a manual rating')\n    }\n    let last_due, last_review, last_lapses\n    switch (processedLog.state) {\n      case State.New:\n        last_due = processedLog.due\n        last_review = undefined\n        last_lapses = 0\n        break\n      case State.Learning:\n      case State.Relearning:\n      case State.Review:\n        last_due = processedLog.review\n        last_review = processedLog.due\n        last_lapses =\n          processedCard.lapses -\n          (processedLog.rating === Rating.Again &&\n          processedLog.state === State.Review\n            ? 1\n            : 0)\n        break\n    }\n\n    const prevCard: Card = {\n      ...processedCard,\n      due: last_due,\n      stability: processedLog.stability,\n      difficulty: processedLog.difficulty,\n      elapsed_days: processedLog.last_elapsed_days,\n      scheduled_days: processedLog.scheduled_days,\n      reps: Math.max(0, processedCard.reps - 1),\n      lapses: Math.max(0, last_lapses),\n      state: processedLog.state,\n      last_review: last_review,\n    }\n    if (afterHandler && typeof afterHandler === 'function') {\n      return afterHandler(prevCard)\n    } else {\n      return prevCard as R\n    }\n  }\n\n  /**\n   *\n   * @param card Card to be processed\n   * @param now Current time or scheduled time\n   * @param reset_count Should the review count information(reps,lapses) be reset. (Optional)\n   * @param afterHandler Convert the result to another type. (Optional)\n   * @example\n   * ```\n   * const now = new Date();\n   * const f = fsrs();\n   * const emptyCard = createEmptyCard(now);\n   * const scheduling_cards = f.repeat(emptyCard, now);\n   * const { card, log } = scheduling_cards[Rating.Hard];\n   * const forgetCard = f.forget(card, new Date(), true);\n   * ```\n   *\n   * @example\n   * ```\n   * interface RepeatRecordLog {\n   *   card: CardUnChecked; //see method: createEmptyCard\n   *   log: RevLogUnchecked; //see method: fsrs.repeat()\n   * }\n   *\n   * function forgetAfterHandler(recordLogItem: RecordLogItem): RepeatRecordLog {\n   *     return {\n   *       card: {\n   *         ...(recordLogItem.card as Card & { cid: string }),\n   *         due: recordLogItem.card.due.getTime(),\n   *         state: State[recordLogItem.card.state] as StateType,\n   *         last_review: recordLogItem.card.last_review\n   *           ? recordLogItem.card.last_review!.getTime()\n   *           : null,\n   *       },\n   *       log: {\n   *         ...recordLogItem.log,\n   *         cid: (recordLogItem.card as Card & { cid: string }).cid,\n   *         due: recordLogItem.log.due.getTime(),\n   *         review: recordLogItem.log.review.getTime(),\n   *         state: State[recordLogItem.log.state] as StateType,\n   *         rating: Rating[recordLogItem.log.rating] as RatingType,\n   *       },\n   *     };\n   * }\n   * const now = new Date();\n   * const f = fsrs();\n   * const emptyCardFormAfterHandler = createEmptyCard(now, cardAfterHandler); //see method:  createEmptyCard\n   * const repeatFormAfterHandler = f.repeat(emptyCardFormAfterHandler, now, repeatAfterHandler); //see method: fsrs.repeat()\n   * const { card } = repeatFormAfterHandler[Rating.Hard];\n   * const forgetFromAfterHandler = f.forget(card, date_scheduler(now, 1, true), false, forgetAfterHandler);\n   * ```\n   */\n  forget<R = RecordLogItem>(\n    card: CardInput | Card,\n    now: DateInput,\n    reset_count: boolean = false,\n    afterHandler?: (recordLogItem: RecordLogItem) => R\n  ): R {\n    const processedCard = TypeConvert.card(card)\n    now = TypeConvert.time(now)\n    const scheduled_days =\n      processedCard.state === State.New\n        ? 0\n        : now.diff(processedCard.last_review as Date, 'days')\n    const forget_log: ReviewLog = {\n      rating: Rating.Manual,\n      state: processedCard.state,\n      due: processedCard.due,\n      stability: processedCard.stability,\n      difficulty: processedCard.difficulty,\n      elapsed_days: 0,\n      last_elapsed_days: processedCard.elapsed_days,\n      scheduled_days: scheduled_days,\n      review: now,\n    }\n    const forget_card: Card = {\n      ...processedCard,\n      due: now,\n      stability: 0,\n      difficulty: 0,\n      elapsed_days: 0,\n      scheduled_days: 0,\n      reps: reset_count ? 0 : processedCard.reps,\n      lapses: reset_count ? 0 : processedCard.lapses,\n      state: State.New,\n      last_review: processedCard.last_review,\n    }\n    const recordLogItem: RecordLogItem = { card: forget_card, log: forget_log }\n    if (afterHandler && typeof afterHandler === 'function') {\n      return afterHandler(recordLogItem)\n    } else {\n      return recordLogItem as R\n    }\n  }\n\n  /**\n   * Reschedules the current card and returns the rescheduled collections and reschedule item.\n   *\n   * @template T - The type of the record log item.\n   * @param {CardInput | Card} current_card - The current card to be rescheduled.\n   * @param {Array<FSRSHistory>} reviews - The array of FSRSHistory objects representing the reviews.\n   * @param {Partial<RescheduleOptions<T>>} options - The optional reschedule options.\n   * @returns {IReschedule<T>} - The rescheduled collections and reschedule item.\n   * \n   * @example\n   * ```\n    const f = fsrs()\n        const grades: Grade[] = [Rating.Good, Rating.Good, Rating.Good, Rating.Good]\n        const reviews_at = [\n          new Date(2024, 8, 13),\n          new Date(2024, 8, 13),\n          new Date(2024, 8, 17),\n          new Date(2024, 8, 28),\n        ]\n\n        const reviews: FSRSHistory[] = []\n        for (let i = 0; i < grades.length; i++) {\n          reviews.push({\n            rating: grades[i],\n            review: reviews_at[i],\n          })\n        }\n\n        const results_short = scheduler.reschedule(\n          createEmptyCard(),\n          reviews,\n          {\n            skipManual: false,\n          }\n        )\n        console.log(results_short)\n   * ```\n   */\n  reschedule<T = RecordLogItem>(\n    current_card: CardInput | Card,\n    reviews: FSRSHistory[] = [],\n    options: Partial<RescheduleOptions<T>> = {}\n  ): IReschedule<T> {\n    const {\n      recordLogHandler,\n      reviewsOrderBy,\n      skipManual: skipManual = true,\n      now: now = new Date(),\n      update_memory_state: updateMemoryState = false,\n    } = options\n    if (reviewsOrderBy && typeof reviewsOrderBy === 'function') {\n      reviews.sort(reviewsOrderBy)\n    }\n    if (skipManual) {\n      reviews = reviews.filter((review) => review.rating !== Rating.Manual)\n    }\n    const rescheduleSvc = new Reschedule(this)\n\n    const collections = rescheduleSvc.reschedule(\n      options.first_card || createEmptyCard(),\n      reviews\n    )\n    const len = collections.length\n    const cur_card = TypeConvert.card(current_card)\n    const manual_item = rescheduleSvc.calculateManualRecord(\n      cur_card,\n      now,\n      len ? collections[len - 1] : undefined,\n      updateMemoryState\n    )\n\n    if (recordLogHandler && typeof recordLogHandler === 'function') {\n      return {\n        collections: collections.map(recordLogHandler),\n        reschedule_item: manual_item ? recordLogHandler(manual_item) : null,\n      }\n    }\n    return {\n      collections,\n      reschedule_item: manual_item,\n    } as IReschedule<T>\n  }\n}\n\n/**\n * Create a new instance of TS-FSRS\n * @param params FSRSParameters\n * @example\n * ```typescript\n * const f = fsrs();\n * ```\n * @example\n * ```typescript\n * const params: FSRSParameters = generatorParameters({ maximum_interval: 1000 });\n * const f = fsrs(params);\n * ```\n * @example\n * ```typescript\n * const f = fsrs({ maximum_interval: 1000 });\n * ```\n */\nexport const fsrs = (params?: Partial<FSRSParameters>) => {\n  return new FSRS(params || {})\n}\n"],"names":["State","t","Rating","e","TypeConvert","card","value","firstLetter","restOfString","ret","timestamp","log","isDay","date_scheduler","pre","unit","date_diff","formatDate","last_review","timeUnit","show_diff_message","now","diff","r","dateInput","date","year","month","day","hours","minutes","seconds","padZero","num","TIMEUNIT","TIMEUNITFORMAT","due","i","fixDate","fixState","fixRating","Grades","FUZZ_RANGES","get_fuzz_range","interval","elapsed_days","maximum_interval","delta","range","min_ivl","max_ivl","clamp","min","max","dateDiffInDays","last","cur","utc1","utc2","default_request_retention","default_maximum_interval","default_w","default_enable_fuzz","default_enable_short_term","FSRSVersion","version","S_MIN","INIT_S_MAX","CLAMP_PARAMETERS","generatorParameters","props","w","index","createEmptyCard","afterHandler","emptyCard","Alea","seed","mash","Mash","state","n","data","h","alea","xg","prng","DECAY","FACTOR","forgetting_curve","stability","FSRSAlgorithm","params","request_retention","_this","target","prop","_params","key","paramKey","g","ivl","fuzz_factor","s","newInterval","delta_d","old_d","d","next_d","difficulty","init","current","hard_penalty","easy_bound","memory_state","s_after_success","s_after_fail","s_after_short_term","new_s","w_17","w_18","next_s_min","DefaultInitSeedStrategy","time","reps","mul","GenSeedStrategyWithCardId","card_id_field","card_id","StrategyMode","AbstractScheduler","algorithm","strategies","grade","item","rating","BasicScheduler","exist","next","easy_interval","good_interval","good_stability","retrievability","next_again","next_hard","next_good","next_easy","item_again","item_hard","item_good","item_easy","nextSMin","hard_interval","LongTermScheduler","again_interval","Reschedule","fsrs","reviewed","next_card","scheduled_days","current_card","reviews","collections","cur_card","review","record_log_item","update_memory","reschedule_card","FSRS","param","enable_short_term","mode","handler","seedStrategy","Scheduler","Seed","recordLog","instance","recordLogItem","format","processedCard","processedLog","last_due","last_lapses","prevCard","reset_count","forget_log","options","recordLogHandler","reviewsOrderBy","skipManual","updateMemoryState","rescheduleSvc","len","manual_item"],"mappings":"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"}